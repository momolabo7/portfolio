<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/tech.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div id=title>tech</div><hr><div id=container><div class=box><h1>Point on triangle algorithms</h1><div><h2><time datetime=2023-05-18T11:16:00+08:00>May 18, 2023</time></h2></div><div><p>A game I&rsquo;m working on requires me to check if a point is overlapped by a triangle.
Being a dumb engineer who can&rsquo;t come up wiith his own algorithm, google gave me 3 algorithms.
Here I&rsquo;m just going to share the algorithms and their performances.</p><p>Parametric:</p><pre><code class=language-cpp>b32_t parametric(v2f_t tp0, v2f_t tp1, v2f_t tp2, v2f_t pt) {
  f32_t denominator = (tp0.x*(tp1.y - tp2.y) + 
                     tp0.y*(tp2.x - tp1.x) + 
                     tp1.x*tp2.y - tp1.y*tp2.x);
  
  f32_t t1 = (pt.x*(tp2.y - tp0.y) + 
            pt.y*(tp0.x - tp2.x) - 
            tp0.x*tp2.y + tp0.y*tp2.x) / denominator;
  
  f32_t t2 = (pt.x*(tp1.y - tp0.y) + 
            pt.y*(tp0.x - tp1.x) - 
            tp0.x*tp1.y + tp0.y*tp1.x) / -denominator;
  
  f32_t s = t1 + t2;
  
  return 0 &lt;= t1 &amp;&amp; t1 &lt;= 1 &amp;&amp; 0 &lt;= t2 &amp;&amp; t2 &lt;= 1 &amp;&amp; s &lt;= 1;
}
</code></pre><p>Dot Product:</p><pre><code class=language-cpp>b32_t dot_product(v2f_t tp0, v2f_t tp1, v2f_t tp2, v2f_t pt) {
  v2f_t vec0 = v2f_set(pt.x - tp0.x, pt.y - tp0.y);      
  v2f_t vec1 = v2f_set(pt.x - tp1.x, pt.y - tp1.y);      
  v2f_t vec2 = v2f_set(pt.x - tp2.x, pt.y - tp2.y);      
  
  v2f_t n0 = v2f_set(tp1.y - tp0.y, -tp1.x + tp0.x);
  v2f_t n1 = v2f_set(tp2.y - tp1.y, -tp2.x + tp1.x);
  v2f_t n2 = v2f_set(tp0.y - tp2.y, -tp0.x + tp2.x);
  
  b32_t side0 = v2f_dot(n0,vec0) &lt; 0.f;
  b32_t side1 = v2f_dot(n1,vec1) &lt; 0.f;
  b32_t side2 = v2f_dot(n2,vec2) &lt; 0.f;
  
  return side0 == side1 &amp;&amp; side0 == side2;
}
</code></pre><p>Barycentric:</p><pre><code class=language-cpp>b32_t barycentric(v2f_t tp0, v2f_t tp1, v2f_t tp2, v2f_t pt) {
  
  f32_t denominator = ((tp1.y - tp2.y)*
                     (tp0.x - tp2.x) + (tp2.x - tp1.x)*
                     (tp0.y - tp2.y));
  
  f32_t a = ((tp1.y - tp2.y)*
           (pt.x - tp2.x) + (tp2.x - tp1.x)*
           (pt.y - tp2.y)) / denominator;
  
  f32_t b = ((tp2.y - tp0.y)*
           (pt.x - tp2.x) + (tp0.x - tp2.x)*
           (pt.y - tp2.y)) / denominator;
  
  f32_t c = 1.f - a - b;
  
  return 0.f &lt;= a &amp;&amp; a &lt;= 1.f &amp;&amp; 0.f &lt;= b &amp;&amp; b &lt;= 1.f &amp;&amp; 0.f &lt;= c &amp;&amp; c &lt;= 1.f;
}
</code></pre><p>Of course, these could be written better but I&rsquo;m just writing it as the algorithm suggested without too much care.
I didn&rsquo;t care about which one was faster until one day I ran a scene with tons of triangles on my Surface Go, which I eventually experienced some slowdown.
That&rsquo;s when I decided to profile them.</p><p>These are the results on my Surface Book 2, with MSVC compiler:</p><table><thead><tr><th style=text-align:left>Algorithm</th><th style=text-align:left>Unoptimized</th><th style=text-align:left>-O2</th></tr></thead><tbody><tr><td style=text-align:left>Barycentric</td><td style=text-align:left>~72 cycles</td><td style=text-align:left>~27 cycles</td></tr><tr><td style=text-align:left>Dot Product</td><td style=text-align:left>~262 cycles</td><td style=text-align:left>~27 cycles</td></tr><tr><td style=text-align:left>Parametric</td><td style=text-align:left>~100 cycles</td><td style=text-align:left>~37 cycles</td></tr></tbody></table><p>It was interesting to see the results.
At first I was surprised to see the Dot Product version so slow because it was what others claimed to be fast, but thankfully after optimization, it ended up being (one of the) fastest.</p></div></div></div></body></html>