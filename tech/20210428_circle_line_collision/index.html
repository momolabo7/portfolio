<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/tech.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div id=title>tech</div><hr><div id=container><div class=box><h1>Circle to Finite Line Collision</h1><div><h2><time datetime=2021-07-04T12:00:00+08:00>Jul 4, 2021</time></h2></div><div><p>Recently, I had to derive this particular collision detection algorithm for my bullet hell genre game. It's an interesting algorithm that can be expanded to deal with the 'moving circle vs static circle' and 'moving circle vs moving circle' problems.</p><h2 id=scenario>Scenario</h2><ul><li><p>We are given a line <code>$ l $</code> where <code>$ \dot{l_{min}} $</code> and <code>$ \dot{l_{max}} $</code> represents the start and end point of the line segment respectively.</p></li><li><p>We are also given a circle, defined by its origin at point <code>$ \dot{c} $</code> and its radius <code>$ r $</code>.</p></li><li><p>The goal is to determine whether the circle is colliding with the line.</p></li></ul><p><img src=/img/blog/20210428_circle_line_collision/1.jpg alt></p><h2 id=general-strategy>General strategy</h2><p>The general idea is to find the point on the line <code>$ l $</code> which will be the shortest distance from the origin of the circle <code>$ \dot{c} $</code>. We will call this point <code>$ \dot{s} $</code>, and the shortest distance <code>$ d $</code>.</p><p>Next, we need to figure out whether this point <code>$\dot{s}$</code> exists within our line segment.</p><p>Finally, we figure out if <code>$ d $</code> is greater than <code>$ r $</code>. If it is not, it means that it is intersecting. For all other cases, it does not intersect.</p><p>In other words:</p><ul><li>Find <code>$ \dot{s} $</code> and <code>$d$</code>.</li><li>Check if <code>$ \dot{s} $</code> exists within our line. If it is not, we are not intersecting.</li><li>Check if <code>$d$</code> is greater than <code>$r$</code>. If it is not, we are intersecting.</li></ul><p><img src=/img/blog/20210428_circle_line_collision/2.jpg alt></p><p>There is a small caveat we need to cover before we continue, regarding checking if <code>$ \dot{s} $</code> exists within our line. It would not cover the case illustrated below.</p><p><img src=/img/blog/20210428_circle_line_collision/3.jpg alt></p><p>Thankfully, this is conceptually easy to solve. We extend our line ends, <code>$ \dot{l_{min}} $</code> and <code>$ \dot{l_{max}} $</code>, by a factor of <code>$r$</code>. We update our list:</p><ul><li>Extend <code>$ \dot{l_{min}} $</code> and <code>$ \dot{l_{max}} $</code> line segment end points by <code>$r$</code></li><li>Find <code>$ \dot{s} $</code> and <code>$d$</code>.</li><li>Check if <code>$ \dot{s} $</code> exists within our line. If it is not, we are not intersecting</li><li>Check if <code>$d$</code> is greater than <code>$r$</code>. If it is not, we are intersecting.</li></ul><h2 id=extend--dotl_min--and--dotl_max--by-a-factor-of--r->Extend $ \dot{l_{min}} $ and $ \dot{l_{max}} $ by a factor of $ r $</h2><p>First, we need to find the unit vector to extend <code>$ \dot{l_{min}} $</code> and <code>$ \dot{l_{max}} $</code>. First, get the vector <code>$ \vec{e} $</code> that goes from <code>$ \dot{l_{min}} $</code> to <code>$ \dot{l_{max}} $</code> by subtracting <code>$ \dot{l_{min}} $</code> from <code>$ \dot{l_{max}} $</code> :</p><p>$ \vec{e} = \dot{l_{max}} - \dot{l_{min}} $</p><p>Then, we normalize it to get the unit vector <code>$ \hat{v} $</code>. We get it by dividing <code>$\vec{e}$</code> by <code>$|\vec{e}|$</code>, where <code>$|\vec{v}|$</code> is the magnitude/length of <code>$ \vec{e} $</code>:</p><p>$ \hat{v} = \dfrac{\vec{e}}{|\vec{e}|} $</p><p>Since <code>$\hat{e}$</code> is the unit vector of <code>$ \vec{e} $</code>, we simply multiply it with <code>$r$</code> to get the amount to translate <code>$ \dot{l_{min}} $</code> and <code>$ \dot{l_{max}} $</code> to 'extend' the line. Thus, our new <code>$ \dot{l_{min}} $</code> and <code>$ \dot{l_{max}} $</code> (which we will denote as <code>$ \dot{l_{min}'} $</code> and <code>$ \dot{l_{max}'} $</code>) will be:</p><p>$ \dot{l_{min}'} = \dot{l_{min}} - (\hat{e} * r) $</p><p>$ \dot{l_{max}'} = \dot{l_{max}} + (\hat{e} * r) $</p><p><img src=/img/blog/20210428_circle_line_collision/9.jpg alt></p><h2 id=find-the-point--dots->Find the point $ \dot{s} $</h2><p>For those familiar with vector arithmetic, to find the point <code>$ \dot{s} $</code>, it is simply the projection of the vector formed by <code>$ (\dot{c} - \dot{l_{min}}) $</code> onto <code>$ \vec{v} $</code>. I would suggest those not familiar with projection to give it a look. Anyway, the formula is simply:</p><p>$ \dot{s} = \dfrac{((\dot{c} - \dot{l_{min}}) ãƒ»\vec{v} }{\vec{|v|}} * \hat{v} + \dot{l_{min}} $</p><h2 id=check-if--dots--is-between--dotl_min--and--dotl_max->Check if $ \dot{s} $ is between $ \dot{l_{min}} $ and $ \dot{l_{max}} $</h2><p>This is easier than it looks. Imaging that we have a line formed by <code>$ \dot{l_{min}} + t(\vec{v}) $</code>, where <code>$t$</code> represents a scalar value such that if it is 0, we will get <code>$ \dot{l_{min}} $</code> and if it is 1, we will get <code>$ \dot{l_{max}} $</code>.</p><p>In other words, <code>$t$</code> is a ratio. Also, since we already know that <code>$ \dot{s} $</code> is definitely on the line, it means that we can safely say that there exists a <code>$t$</code> such that:</p><p>$ \dot{l_{min}} + t(\vec{v}) = \dot{s} $</p><p>We can then choose any element of <code>$\vec{v}$</code> to find <code>$t$</code>. Note that the element that you choose from <code>$ \vec{v} $</code> must not be 0.</p><p>I.e. if <code>$ v_x = 0 $</code>, use <code>$ v_y $</code> instead, etc. There won't be a case where all elements of <code>$\vec{v}$</code> is 0 because...that wouldn't form us the line <code>$l$</code> anymore.</p><p>$ \dot{l_{min}}_x + t(v_x) = s_x $</p><p>$ t(v_x) = s_x - \dot{l_{min}}_x $</p><p>$ t = \dfrac{(s_x - \dot{l_{min}}_x)}{v_x} $</p><p>If <code>$t$</code> is lesser than 0 or greater than 1, we are not colliding. Otherwise, we go to the final section.</p><h2 id=check-the-distance-between-the-circle-and-the-line>Check the distance between the circle and the line</h2><p>Finally, we want to find the shortest distance <code>$d$</code> between the circle and the line. With that, we will compare it against the radius of the circle <code>$r$</code>. This is simply finding the distance between <code>$\dot{c}$</code> and <code>$\dot{s}$</code> using our favorite Pythagoras Theorem, and comparing it against <code>$r$</code>.</p><p>In fact, if you do not like dealing with square roots, we can just compare the <code>$d^2$</code> with <code>$r^2$</code></p><p>$ d^2 = (\dot{c} - \dot{s})_x * (\dot{c} - \dot{s})_x + (\dot{c} - \dot{s})_y * (\dot{c} - \dot{s})_y $</p><p>$ r^2 = r * r $</p><p>If <code>$d^2$</code> &lt; <code>$r^2$</code>, then we have a collision!</p><h2 id=extra-1-moving-circle-vs-static-circle>Extra 1: Moving circle vs static circle</h2><p>Now that we have this, we can expend this concept to deal with moving circle vs static circle. What we have visually is something like the following:</p><p><img src=/img/blog/20210428_circle_line_collision/4.jpg alt></p><p>As far as collision detection is concerned, we can simply add the moving circle's radius <code>$r_1$</code> to the static circle's radius <code>$r_2$</code> and get the diagram below:</p><p><img src=/img/blog/20210428_circle_line_collision/5.jpg alt></p><p>And we can just apply our circle and line algorithm!</p><h2 id=extra-2-moving-circle-vs-moving-circle>Extra 2: Moving circle vs Moving circle</h2><p>Now for the last bit: What if we have two moving circles?</p><p><img src=/img/blog/20210428_circle_line_collision/6.jpg alt></p><p>Just like the algorithm we did for 'moving circle vs static circle', we try to link the problem back to collision between a circle and a line. This means that we have to make one of the circles static.</p><p>In this case, we choose to make <code>$\dot{c_2}$</code> static. For this, we simply add the <em>reverse</em> of it's velocity <code>$\vec{v_2}$</code> to the moving circle's velocity <code>$\vec{v_1}$</code>. It's a little unintuitive to think about especially when the circles can move at all kinds of direction (the diagram is the a simplistic example), but it is related to the idea 'relative motion'.</p><p><img src=/img/blog/20210428_circle_line_collision/7.jpg alt></p><p>One way to think about it is to imagine that <code>$\dot{c_1}$</code> and <code>$\dot{c_2}$</code> are moving trains, and that you are on, in this case, <code>$\dot{c_2}$</code>. What you would feel, even though the train is moving, is that you are still, and when you see the train <code>$\dot{c_1}$</code> approaching, it is moving with the combined velocity of itself and the reverse of your train (i.e. it's seems to be moving a lot faster than it should).</p><p>Now that we have a moving circle and a static circle, we can simply add the moving circle's radius <code>$r_1$</code> to the static circle's radius <code>$r_2$</code>, just like what we did in 'moving circle vs static circle'!</p><p><img src=/img/blog/20210428_circle_line_collision/8.jpg alt></p></div></div></div></body></html>