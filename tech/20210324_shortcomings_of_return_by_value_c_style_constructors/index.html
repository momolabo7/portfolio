<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/tech.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div id=title>tech</div><hr><div id=container><div class=box><h1>A small shortcoming of return-by-value</h1><div><h2><time datetime=2021-03-24T12:00:00+08:00>Mar 24, 2021</time></h2></div><div><p>Recently, while coding on my personal C/C++ game engine project, I ran into a surprising shortcoming of functions that returns an object by value. This was when I was still trying to keep things consistant in my project and went for a functional-programming style.</p><p>Consider that there are generally two simple ways to modify an object in C/C++ through plain functions.</p><p>Returning by value:</p><pre><code class=language-cpp>struct v2f {
    float x, y; 
};

v2f CreateV2f(float x, float y) {
    return v2f { x, y };
}

// Usage
v2f Vec = CreateV2f(1.f, 2.f);
</code></pre><p>Modifying by pointer:</p><pre><code class=language-cpp>struct v2f {
    float x, y; 
};

void InitV2f(v2f* Vec, float x, float y) {
    Vec-&gt;x = x;
    Vec-&gt;y = y;
}

// Usage
v2f Vec = {};
InitV2f(&amp;Vec, 1.f, 2.f);
</code></pre><p>We can spend hours arguing about which one is better, but optimization and code readability aside, we can all agree that both functions generally does the same thing, at a relatively good speed.</p><p>So I have been using both styles interchangably for awhile now. Some scenarios, I feel like the first method is better while other times, the second feels better. Generally, it felt like both methods are interchangable. I ended up just going for the return-by-value style because copy elision is a thing. I did not profile the performance differences between the two styles so call it 'premature optimization' if you will, but I just wanted some consistency in my code.</p><p>However I found a <em>slightly</em> unexpected shortcoming of the return-by-value method. Consider the scenario:</p><pre><code class=language-cpp>// Simple lightweight 'string' object.
struct String {
    char* data;
    int cap;
    int count;
};
String CreateString(char* buffer, int cap) {
    String ret = {};
    ret.data = buffer;
    ret.cap = cap;
};

struct StringWithBuffer {
    u8 buffer[256];
    String str; 
};

StringWithBuffer CreateStringWithBuffer() {
    StringWithBuffer ret = {};
    ret.str = CreateString(ret.buffer, 256);

    return ret; 
}

// Usage
StringWithBuffer foo = CreateStringWithBuffer();
// foo.str.data will not point to foo.str.buffer!
</code></pre><p>After calling <code>CreateStringWithBuffer()</code>, <code>foo.str.data</code> member will be pointing at an invalid address and not <code>foo.buffer</code>! This is obvious when you work out what happened step by step. Within <code>CreateStringWithBuffer()</code>, <code>ret.str.data</code> would end up correctly pointing to <code>ret.buffer</code>. However, <code>ret</code> is actually a temporary object, so <code>ret.buffer</code> will naturally become invalid after the function is done. It's obvious after pointing it out, but I think it's fair to say that most of us thought that there would not be a problem with <code>CreateStringWithBuffer()</code>, because it looks so straightforward and simple.</p><p>Thinking about it, C++ constructors will never have this issue because you are modifying <code>this</code> and returns a reference to itself. (However, I have a lot of things against C++ constructors, which I might go into another article when I can).</p><p>Thankfully, the pointer version will not have the issue:</p><pre><code class=language-cpp>// Simple lightweight 'string' object.
struct String {
    char* data;
    int cap;
    int count;
};
String CreateString(char* buffer, int cap) {
    String ret = {};
    ret.data = buffer;
    ret.cap = cap;
};

struct StringWithBuffer {
    u8 buffer[256];
    String str; 
};

void CreateStringWithBuffer(StringWithBuffer* Foo) {
    Foo-&gt;Str = CreateString(Foo-&gt;Buffer, 256);
}

// Usage
StringWithBuffer foo = {};
CreateStringWithBuffer(&amp;foo);
// foo.str.data correctly points to foo.str.buffer!
</code></pre><p>In the end, I really shouldn't have cared that much.</p></div></div></div></body></html>