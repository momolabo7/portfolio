<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/tech.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title></head><body><div id=title>tech</div><hr><div id=container><div class=box><article><header><h1 class=link><a href=/tech/20240525_considering_hash_tables/>Considering Hash Tables</a></h1><h2><time datetime=2024-05-25T12:00:00+08:00>May 25, 2024</time></h2></header><div><p>For a while, I&rsquo;ve been meaning to write some kind of a hash table from scratch for my own projects. Surprisingly for my game projects so far, I had totally avoided use of hashes and managed to optimise my problems to use simple dense arrays. The closest I came to using hash tables was when I wrote my profiler which identifies entries by hardcoded strings (which I could cheat by using their addresses instead but that&rsquo;s another story).</p></div><hr></article><article><header><h1 class=link><a href=/tech/20240102_js_api_design_with_closures_with_property_injection/>JS API Design Thoughts</a></h1><h2><time datetime=2024-01-02T12:00:00+08:00>Jan 2, 2024</time></h2></header><div><p>This is probably one of the wierdest things I had to wrap my head around Javascript recently.
It&rsquo;s a combination of how closures work, functions being first class objects and that you can add properties into objects.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20231212_overlay_pixel_shader/>Overlay Pixel Shader Transforms</a></h1><h2><time datetime=2023-12-12T12:00:00+08:00>Dec 12, 2023</time></h2></header><div><p>This post is just to document for my own reference the math that went behind the transformations (scale, rotate, translate) of the overlay pixel shader I wrote for Reshade <a href=https://github.com/momohoudai/momo_reshade>here</a>.
It turns out that it was a little more tricky than I initially expected.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20231106_javascript_reflections_2023/>Reflections on using Javascript in 2023</a></h1><h2><time datetime=2023-11-06T08:00:00+08:00>Nov 6, 2023</time></h2></header><div><p>Recently, I have been writing quite a bit of Javascript for a couple of side-projects.
I was a little inspired to attempt to write simple webapps without the use of any frameworks.
One of them is avaliable here: <a href=https://momohoudai.github.io/fvf/>FvF</a>.
This post is just some personal reflections going back to use vanilla Javascript/CSS in 2023.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20230517_overlapping_triangles/>Point on triangle algorithms</a></h1><h2><time datetime=2023-05-18T11:16:00+08:00>May 18, 2023</time></h2></header><div><p>A game I&rsquo;m working on requires me to check if a point is overlapped by a triangle.
Being a dumb engineer who can&rsquo;t come up wiith his own algorithm, google gave me 3 algorithms.
Here I&rsquo;m just going to share the algorithms and their performances.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20230505_cpp_boolean_flattening_trick/>C++ Flatten integer to 0/1</a></h1><h2><time datetime=2023-05-05T13:25:00+08:00>May 5, 2023</time></h2></header><div><p>This is a quick trick to &lsquo;flatten&rsquo; an integer into a 1 or 0.
This is probably a trick that only works in C/C++ because of how the not (!) operator works with integers.
While it&rsquo;s usefulness is dubious in C++, it might be useful in C.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20230411_index_match_tldr/>Excel INDEX/MATCH tl;dr</a></h1><h2><time datetime=2023-04-10T12:00:00+08:00>Apr 10, 2023</time></h2></header><div><p>I was playing with Excel recently and for the hundredth time got stumped by how to use the INDEX/MATCH combo.
For the hundredth time in the past years, I open the same damn website and the same damn explanation which took awhile because my brain actually needed to work to understand what&rsquo;s going on.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20230312_rpi_cookbook/>My Raspberry PI Cookbook</a></h1><h2><time datetime=2023-03-12T12:00:00+08:00>Mar 12, 2023</time></h2></header><div><p>I figured that I might as well save a Raspberry PI cookbook somewhere.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20220425_derive_triangle_to_triangle_transform/>Deriving Triangle to Triangle transformation matrix</a></h1><h2><time datetime=2022-04-25T23:00:00+08:00>Apr 25, 2022</time></h2></header><div><p>Here&rsquo;s how I derive the transformation matrix for getting from triangle A to triangle B to do shadows in my 2D engine.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20211118_bytes_alignment_notes/>Byte Alignment Notes</a></h1><h2><time datetime=2021-11-18T12:00:00+08:00>Nov 18, 2021</time></h2></header><div><p>When dealing with raw memory directly, there might come the need to align your memory to the nearest of some power of 2.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20210924_dirty_c/>Dirty C/C++</a></h1><h2><time datetime=2021-09-24T12:00:00+08:00>Sep 24, 2021</time></h2></header><div><p>Here is a collection of cool snippets of C/C++ code. Updated regularly. Used to show superiority and implode the minds of my students. Also to use in my own code, of course, whenever viable.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20210801_perspective_projection_matrix/>Perspective Projection Matrix</a></h1><h2><time datetime=2021-08-01T12:00:00+08:00>Aug 1, 2021</time></h2></header><div><p>I was searching around internet for a full derivation for the 3D Perspective Projection Matrix to apply to my handmade software renderer and I was surprised by how little information I could find about it. That prompted me to write this post, to document the derivation of the matrix, at least in my own eyes.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20210428_circle_line_collision/>Circle to Finite Line Collision</a></h1><h2><time datetime=2021-07-04T12:00:00+08:00>Jul 4, 2021</time></h2></header><div><p>Recently, I had to derive this particular collision detection algorithm for my bullet hell genre game. It&rsquo;s an interesting algorithm that can be expanded to deal with the &lsquo;moving circle vs static circle&rsquo; and &lsquo;moving circle vs moving circle&rsquo; problems.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20210406_glue_c_preprocessor_trick/>[C/C++] The 'Glue' Preprocessor Trick</a></h1><h2><time datetime=2021-04-06T12:00:00+08:00>Apr 6, 2021</time></h2></header><div><p>Macro tricks are rare to find nowadays.
Sometimes, I would code and <em>know</em> of a trick but had forgotten how to go about implementing it because they can look as arcane as Template Metaprogramming.
Hopefully, I can document some of my knowledge of these tricks in this blog.
Here, I will introduce what I call the &lsquo;Glue&rsquo; macro trick.</p></div><hr></article><article><header><h1 class=link><a href=/tech/20210324_shortcomings_of_return_by_value_c_style_constructors/>A small shortcoming of return-by-value</a></h1><h2><time datetime=2021-03-24T12:00:00+08:00>Mar 24, 2021</time></h2></header><div><p>Recently, while coding on my personal C/C++ game engine project, I ran into a surprising shortcoming of functions that returns an object by value. This was when I was still trying to keep things consistant in my project and went for a functional-programming style.</p></div><hr></article></div></div></body></html>