<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/construction.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title></head><body><div id=container><div id=title>tech</div><div class=box><h1>Byte Alignment Notes</h1><div><time datetime=2021-11-18T12:00:00+08:00><h2>Nov 18, 2021</h2></time></div><div><p>When dealing with raw memory directly, there might come the need to align your memory to the nearest of some power of 2.</p><p>Typically you would want to do this when you are reading and writing to a data structure that uses raw bytes, like a memory arena that can contain different types for instance. Aligning values by their types minimizes cache trashing. This is because memory is typically read WORD by WORD. This means that 32-bit systems will read in 4 byte chunks and 64-bit systems will read 8 byte chunks.</p><p>For example, in 32-bit systems, memory is pulled into your CPU in blocks of 4 byte chunks (e.g. 0x00 to 0x03, 0x04 to 0x07, 0x08 to 0x0C). If you do not align your bytes properly, you might end up in a situation where you have to read more than necessary from memory to get a value out. To illustrate this, let&rsquo;s say we have a diagram like below that represents memory of a 32-bit system.</p><p><img src=/img/blog_img/20211118/blank_32_bit_memory.png alt=blank_32_bit_memory></p><p>And an aligned 4-byte integer value would be packed something like this:</p><p><img src=/img/blog_img/20211118/blank_32_bit_memory_aligned_int.png alt=blank_32_bit_memory></p><p>When retrieving an aligned 4-byte integer this way, a 32-bit CPU only needs to do a single read on the 0x04 - 0x07 chunk (the red-dotted box represents 1 read ). However, a misaligned 4-byte integer might end up requiring more reads:</p><p><img src=/img/blog_img/20211118/blank_32_bit_memory_unaligned_int.png alt=blank_32_bit_memory></p><p>In terms of efficiency, chances are we want to align our bytes, even if it costs slightly more memory. On top of that, there are also systems which flat out do not support reading of unaligned bytes, so there&rsquo;s that consideration for portability too. This is because it is much easier for the CPU to read aligned bytes than not, thus they might not support reading unaligned bytes.</p><p>So what bytes should we align our types to? To ensure that the CPU reads a type with the minimum amount of reads, we align them to a number that is divisible by their size. This means a 2 byte structure would align to a memory address that is a multiple of 2, a 4 byte structure would align to a memory address that is a multiple of 4, so on and so forth. Notice that we only ever want to align to powers of 2.</p><p>How do we align?</p><p>First, let&rsquo;s get our inputs. Given a memory address A and the byte to align N where N is a power of 2, we can come up with some concrete examples:</p><ul><li>To align 0011 (3) to 4-byte, the result should be 0100 (4)</li><li>To align 0110 (6) to 4-byte, the result should be 1000 (8)</li></ul><p>To align, we need to remove the log2(N) least significant bits from A. This means that for 2 byte alignment, we want to remove ONLY the last bits and retain the rest of the bits.</p><ul><li>2 byte alignment -> remove 1 least significant bits</li><li>4 byte alignment -> remove 2 least significant bits</li><li>8 byte alignment -> remove 3 least significant bits</li><li>etc&mldr;</li></ul><p>Some concrete examples:</p><ul><li>To align to 2 bytes (0010), we need to do <code>A & (1110)</code></li><li>To align to 4 bytes (0100), we need to do <code>A & (1100)</code></li><li>To align to 8 bytes (1000), we need to do <code>A & (1000)</code></li><li>etc&mldr;</li></ul><p>Thus, the &lsquo;mask&rsquo; to &lsquo;&&rsquo; against can be defined as <code>~(N-1)</code>, such that:</p><ul><li>To align to 2 bytes (0010), the mask is ~(0010 - 1) = ~0001 = 1110</li><li>To align to 4 bytes (0100), the mask is ~(0100 - 1) = ~0011 = 1100</li><li>To align to 8 bytes (1000), the mask is ~(1000 - 1) = ~0111 = 1000</li></ul><p>And therefore, the formula for aligning a memory address backwards to an alignment value is: <code>A & ~(N-1)</code></p><p>Aligning a memory address forward is straightforward; we simply add (N - 1) to the memory address before applying the formula above: <code>(A + (N-1)) & (~N-1)</code></p><p>Below are functions for the formulas above in C:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>AlignMemoryBackward</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr, <span style=color:#66d9ef>uint8_t</span> align) {
</span></span><span style=display:flex><span>    assert((align <span style=color:#f92672>&amp;</span> (align <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// power of 2 only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)(umi(ptr) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(align <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> 
</span></span><span style=display:flex><span><span style=color:#a6e22e>AlignMemoryForward</span>(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> ptr, <span style=color:#66d9ef>uint8_t</span> align) {
</span></span><span style=display:flex><span>    assert((align <span style=color:#f92672>&amp;</span> (align <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// power of 2 only
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)((umi(ptr) <span style=color:#f92672>+</span> (align <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>~</span>(align <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As an additional note, it would be hasty (and I did this many times) to assume that it is okay to always align an object by its <code>alignof</code> value. That is, aligning characters by 1, aligning shorts by 2 and aligning longs by 4, etc. That would solve the issue of certain CPUs rejecting unaligned access, for sure. But if we are <strong>really</strong> concerned about cache hits/misses, we would want manually align them anyway. For example, if you want to take advantage of SIMD instructions, you might need to align all your data to 16 bytes anyway.</p><p>At the end of the day, what value we want to align to depends on the use case.</p></div></div></div></body></html>