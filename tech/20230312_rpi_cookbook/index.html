<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/tech.css><link rel=stylesheet href=/css/prism.css><script src=/js/prism.js></script><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title>
<script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div id=title>tech</div><hr><div id=container><div class=box><h1>My Raspberry PI Cookbook</h1><div><h2><time datetime=2023-03-12T12:00:00+08:00>Mar 12, 2023</time></h2></div><div><p>I figured that I might as well save a Raspberry PI cookbook somewhere.</p><p>Note that these are for Raspberry PI OS.
Some of these will work on other Linux distributions (especially Debian since Raspbian derives from it).
te that these are for Raspberry PI OS.</p><p>But you know, Linux being linux and distributions being distributions, not all of them will work for everything.
Since I only use Raspberry PI right now, I'll just stick to the commands being for the Raspberry PI.</p><p>I will update this cookbook every now and then when I play with my PI.</p><h1 id=user>User</h1><p>Check what groups the current user is under</p><pre><code class=language-sh>groups
</code></pre><h1 id=disk-space>Disk space</h1><p>Displaying disk space in human-readable format</p><pre><code class=language-sh>df -h
</code></pre><h1 id=processes>Processes</h1><p>Displaying processes</p><pre><code class=language-sh>ps
</code></pre><p>Monitor processes (press 'q' to quit)</p><pre><code class=language-sh>htop
</code></pre><h1 id=file>File</h1><p>Monitoring a file</p><pre><code class=language-sh># Monitors the last N lines of a file
# -n is optional
tail -n [N]  -f [FILENAME]
</code></pre><p>Printing a file</p><pre><code class=language-sh>cat [FILENAME]
</code></pre><p>Printing a in reverse (line-wise)</p><pre><code class=language-sh>tac [FILENAME]
</code></pre><p>Grepping a file</p><pre><code class=language-sh>grep [OPTIONS (optional)] [PATTERN] [FILES]

# for example, this greps all &quot;hello&quot; in the files main.c and main.h
grep hello main.c main.h
</code></pre><p>Grepping a file with regex</p><pre><code class=language-sh>grep -E [PATTERN] [FILES]
</code></pre><h1 id=network>Network</h1><p>Displays active network connections and their corresponding processes</p><pre><code class=language-sh>sudo netstat -nltp
</code></pre><h1 id=enable-vnc-and-ssh>Enable VNC and SSH</h1><p>Open the terminal on the RPI, then:</p><pre><code class=language-sh>sudo raspi-config
</code></pre><p>Select [Interfacing Options] > VNC > Yes > Ok</p><h1 id=enable-ssh-with-publicprivate-key-authentication>Enable SSH with public/private key authentication</h1><p>Let's define device R as the RPI and device C as the computer you want to connect from.
We assume that C has already generated its public/private key pair.</p><p>Open the terminal on R, then:</p><pre><code class=language-sh>sudo raspi-config
</code></pre><p>Select [Interfacing Options] > SSH > Yes > Ok</p><p>Then, make the following directory:</p><pre><code class=language-sh>install -d -m 700 ~/.ssh
</code></pre><p>Open your favourite text editor (e.g. nano, vim, nvim) on <code>~/.ssh/authorized_keys</code>. I like vim so:</p><pre><code class=language-sh>sudo vim ~/.ssh/authorized_keys
</code></pre><p>Then somehow, someway, copy paste the public key from device C into that file and save.</p><p>Then, make sure that the permissions of that file is set correctly:</p><pre><code class=language-sh>sudo chmod 644 ~/.ssh/authorized_keys
</code></pre><p>Finally, we have to disable password authentication.
Open the following file:</p><pre><code class=language-sh>sudo vim /etc/ssh/sshd_config
</code></pre><p>Add the following line:</p><pre><code class=language-sh>PasswordAuthentication no
</code></pre><p>For any errors related to this, the log is avaliable at this file:</p><pre><code class=language-sh>/var/log/auth.log
</code></pre><p>NOTE: You can, of course, use <code>ssh-copy-id</code> command from device C to setup the RSA authentication on device R.
It basically does the steps related to placing device C's public key into device R's <code>authorized_keys</code> file.
That assumes that you DO have <code>ssh-copy-id</code> available in device C.</p><h1 id=docker>Docker</h1><h2 id=installation>Installation</h2><p>Run the crazy script that will setup Docker.</p><pre><code class=language-sh>curl -sSL https://get.docker.com | sh
</code></pre><p>Any user that requires Docker will need to be added to the 'docker' group.
Let's say my username is 'momo', I will then do the following:</p><pre><code class=language-sh>sudo usermod -aG docker momo
</code></pre><p>Log out and log in again for the changes to take effect.
After you log in, enter the command below display the list of groups you are under.</p><pre><code class=language-sh>groups
</code></pre><p>Check that 'docker' is in the list displayed.</p><p>To test that Docker is running, do the following:</p><pre><code class=language-sh>docker run hello-world
</code></pre><p>You should see text displayed as follows:</p><pre><code class=language-txt>Hello from Docker!
This message shows that your installation appears to be working correctly.
</code></pre><h2 id=useful-commands>Useful commands</h2><p>Clean up any unused resources (including images)</p><pre><code class=language-sh>docker system prune -a
</code></pre><p>List all containers</p><pre><code class=language-sh>docker ps -a
</code></pre><p>Remove containers</p><pre><code class=language-sh>docker rm [CONTAINER ID OR NAME...]

# Example: removing all containers
docker rm $(docker ps -a -q)
</code></pre><p>List all images</p><pre><code class=language-sh>docker images -a
</code></pre><p>Remove images.</p><pre><code class=language-sh>docker rmi [Images...]

# Example: removing ALL images
docker rmi $(docker images -a -q)
</code></pre><p>Stop container.</p><pre><code class=language-sh>docker stop [CONTAINER ID OR NAME]

# Example: stops all containers
docker stop $(docker ps -a -q)
</code></pre><p>Compose: setups up a bunch of container and...does a bunch of things.
Docker Compose needs a YML file to run.
By default, it runes docker-compose.yml in the current directory.</p><pre><code class=language-sh>docker compose up -d 
</code></pre><h1 id=systemdservice>systemd.service</h1><p>systemd.service is a way to manage your application into services in Debian/Ubuntu based Linux.
Simply write create a file with a .service extention containing content like this:</p><pre><code class=language-sh>[Unit]
Description=My discord bot service
After=network.target

[Service]
ExecStart=/command/to/execute
WorkingDirectory=/home/place/to/execute
StandardOutput=inherit
StandardError=inherit
Restart=always


[Install]
WantedBy=multi-user.target
</code></pre><p>Toss it into <code>/etc/systemd/your_app.service</code>, and you could be able to use it like a service.</p><pre><code class=language-sh>systemctl start your_app
</code></pre></div></div></div></body></html>