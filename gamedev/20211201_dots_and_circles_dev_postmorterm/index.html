<html lang=en><head><meta charset=UTF-8><link rel=stylesheet href=/css/gamedev.css><link rel="shortcut icon" type=image/png href=/img/favicon.png><title>moom</title></head><body><div id=container><div id=title>games</div><div id=about>hey! this is just a place for me to talk about games, gamedev and game design!</div><div id=single_box><span id=single_title>Dots and Circles Dev Postmorterm</span>
<span id=single_time><time datetime=2021-12-01T23:00:00+08:00>Dec 1, 2021</time></span><hr><p>Alright, the game is <a href=https://momohoudai.itch.io/dots-and-circles>out on itch.io</a> for free! Now that some time has passed and a handful of people have played the game, I felt that there is no better time then to jot down my experiences developing this small arcade game, lest I forget (again).</p><p>Before I talk about the game, I&rsquo;ll share some context about the philosophy I had making this game, what this game really is about to me and why did I do this.</p><p>I had been studying and doing game development for over a decade, with 6 years in professional capacity. After releasing a few games ranging from web to console titles, I got bored of using ready-made technologies to drive my products. I became more interested in learning how the technologies themselves work, than learning how to use them. I wanted to learn how not to rely on them too much, because the lifespan and efficacy of a product can be very volatile. On top of that, learning the fundamentals that a technology is built on also allows me to move between similar technologies and use them more effectively.</p><p>With that understanding in my, I came across <a href=https://handmadehero.org/>Handmade Hero</a>. There, I saw a movement of projects that are &lsquo;handmade&rsquo;, meaning they use as little libraries as they can reasonably afford. Upon seeing so many inspirational projects, some of which I now use, I decided that I&rsquo;ll go back to my roots and code an engine and a game, with the game being the main driving force that will shape the engine.</p><p>As you can tell by now, this is going to be a bit rant-y, but hopefully a good read for whoever is bored enough to read it. I&rsquo;ll go by chronological order, as much as I can remember them.</p><h2 id=platform-layer>Platform Layer</h2><p>At first, I decided to use SDL2 for portability. It was working fine, but I wanted to have the hot reloading figure that Casey did in Handmade Hero for development. It&rsquo;s a system where the game code could be reloaded while the whole application is running. I wanted the same system where the application would be able to detect that the game&rsquo;s DLL is modified and reload the code, which will be really useful for iteration.</p><p>That&rsquo;s when I found that SDL&rsquo;s file IO API did not allow me to check for a file&rsquo;s last modified timing. I would have to use the OS&rsquo;s API instead. At that point, I figured that even if I did everything using SDL, there is a good chance that it&rsquo;s going to be riddled with <code>#if</code> macros containing specific OS code anyway, which might end up difficult to read. That&rsquo;s when I decided that, in the name of education, I&rsquo;m going to write the platform layer using straight Windows API. Perhaps I will use SDL for Linux systems when there are so many different components.</p><p>Writing the platform layer straight from the OS&rsquo; API was incredibly educational. I learnt the true nature of file systems, memory allocation, performance counters, windows/context management, input management and audio management that were usually hidden away from cross-platform libraries like SDL, SFML and STL.</p><p>For example, for memory management, I previously had no idea about the concept of &lsquo;allocate&rsquo; and &lsquo;commit&rsquo;. It&rsquo;s actually insane how much these libraries hide from us.</p><h2 id=graphics-programming>Graphics Programming</h2><p>One of the things I quickly decided was to use OpenGL. Graphics programming was something that I really missed out in my time as a game developer. Considering what I was good at and the people I usually interact with at work, I would probably never learn it in a professional capacity.</p><p>I initially had hopes of writing and hand-rolling a software renderer. Even though I managed to handroll one in a separate project, I decided against it because I wasn&rsquo;t willing to put hours in to optimize the processes.</p><p>In OpenGL, I went straight to using Direct State Access and implementing instancing. Things turned out really well in my stress tests, where I found that I was being bottlenecked by multiple texture bindings. Although I did my best to limit the amount of binds, it did not hit my standards.</p><p>Admittedly though, my standards at that time was a little high. I think I tested for 10000 entities rendering at same time, which was way more than the 500 or so maximum objects I ended up having in the game. I was so excited by the fact that I was able to actually feel the lag time decrease that I kind of decided to deal with having either texture arrays or a spritesheets.</p><p>Since my game is 2D with no mipmapping, and because I&rsquo;m more familiar with spritesheets, it was a bit of a no brainer for me to go for that. Perhaps next time, I&rsquo;ll take a closer look at texture arrays and their implications.</p><p>This lead to writing a texture packer, and also dealing with the game&rsquo;s assets system.</p><h2 id=assets-system>Assets System</h2><p>This is the part of the game which I flip-flopped many times. It was really hard to decide on an asset system that scales, because the more you try to make it scalable, the more you might lose. For example, I could go into an asset system that loads assets on a separate thread on demand but do I really want player to play games with a missing sound or texture?</p><p>At some point, it seems to me that the best asset system for a game would be an asset system that&rsquo;s really catered for the game. This was when I figured that I had to decide what game to make. Otherwise I would be stuck in this loop forever.</p><h3 id=sidetrack-selecting-the-game-to-make>Sidetrack: Selecting the game to make</h3><p>I have went through several cycles of game development and lead teams before, so trying to keep my expectations realistic wasn&rsquo;t too hard. I started off by having a direction, which was to have a simple game. I understand that this was a dangerous statement to make. Before veteran game developers rise their pitchforks against me, hear me out. When I said &lsquo;simple game&rsquo;, the emphasis was mostly on the word &lsquo;game&rsquo;. This means that it must have</p><ul><li>A way to start</li><li>A way to play something repeatedly</li><li>A way to quit</li></ul><p>In other words, my minimum requirement was to have some kind of gameplay loop. For the actual game itself, I tried to think of the least I needed to do.</p><p>I started a prototype a bit, and managed to get WASD working, mouse working (window-space to game space conversion), and enemies spawning. At that point, it became obvious what to make as a small proof of concept for the engine: a bullet hell game.</p><p>That&rsquo;s when I thought about a game I made with a friend during my freshmen years in university, a game called Dots and Circles which you could still find in the <a href=https://games.digipen.edu/games/dots-n-circles>DigiPen Game Gallery</a>. It&rsquo;s also one of the reasons why this game is free; it&rsquo;s because I was too lazy to repackage the IP into something different.</p><p>Despite having a game to reference, there was still much work to be done. I wanted to draw my own sprites, compose my own music and generate my own sound effects. The direction of the game would be different too, especially since I don&rsquo;t have requirements to follow other than my own.</p><p>But the logic would be simple to implement. It&rsquo;s just processing arrays of bullets, array of particles and even array of numbers to show big scores.</p><h3 id=back-to-the-assets-system>Back to the Assets System</h3><p>The assets system is straightforward. What I essentially do is to have a single asset file in binary containing all the data my game needs. This asset file is generated outside the game, which means that my PNG files, WAV files, etc are all processed and translated into something that could be easily understood by my game.</p><p>Within the game, I simple store them into a really dumb array.</p><p>Yes. An array of textures. An array of sounds. An array of messages. All loaded when the game starts. All easily indexed by their respective enums. Yes. Enums. <code>IMAGE_SPLASH</code>, <code>SOUND_EXPLOSION</code>, <code>FONT_DEFAULT</code>&mldr;that kind of stuff.</p><p>The problem I had was the fact that I decided to use texture atlas. Packing all the art assets into a single atlas wasn&rsquo;t the problem; I just wrote a tool that works like Texture Packer (which I refuse to pay a second time), which honestly wasn&rsquo;t that difficult once you get the algorithm down.</p><p>The main issue I had was figuring out how to express pushing images and text when I&rsquo;m programming on the game layer. It can be really unintuitive as a person programming on the game layer to pass an Image&rsquo;s data (which minimally contains UV) and the texture atlas that that it targets. This seems easy to solve; I just need the Image to store the handle to it&rsquo;s texture atlas.</p><p>But what happens when the texture is not there?</p><p>Well, I didn&rsquo;t solve it in the end. I just assumed that the texture is always there. Trust me, I tried to solve it, but one hypothetical problem always lead to even more hypothetical problem and&mldr;the problems to solve just increases exponentially. After writing and deleting much code, I decided to focus on reality, and the reality is that my game will ALWAYS assume that all assets are loaded. If any of the assets fail to load, it would fail to launch anyway.</p><p>Dealing with fonts had a similar issue. Font Glyphs (which are the font &lsquo;Images&rsquo;) will have a handle to a texture atlas and a handle to the overall Font data, both of which are assumed to be loaded already.</p><p><em>By the way, font was really annoying to figure out. God bless the person who wrote this <a href=https://simoncozens.github.io/fonts-and-layout/>guide</a>.</em></p><p>&ldquo;But what happens if I want to load the game differently at some point?&rdquo;</p><p>Then I&rsquo;ll change the system. Simple as that, really. If I had continued to solve hypothetical non-existent problems, I would not be able to complete any project. Trust me, I&rsquo;ve been there. So I stopped, decided that it&rsquo;s not a problem until it&rsquo;s a problem, and moved on.</p><p>Ah, the beauty of having a target game.</p><h2 id=sound-and-audio>Sound and Audio</h2><p>I had to talk about audio because I made a few decisions that seemed harmless but was a little annoying to deal with. I decided that it would be cool that the game would &lsquo;pulse&rsquo; to the beat of the background music. I also made the decision to allow users to change devices. I managed to make both work, until I found that there is a way for users to have the animations not syncing with the music. You see, the problem was that my audio was not updating when there is no device. This is because audio systems (at least, my audio system) updates differently from the rest of the game.</p><p>The game updates based on frames, or rather, time between frames. This means that even if the CPU is fast or slow, the game will move according to what we humans know as time.</p><p>Audio doesn&rsquo;t work like that, at least, my current understanding of it. All you have is a buffer to push your sound, and when the device is able, it will consume the buffer and vibrate the speakers. Without an audio device, the buffer I gave the game was (correctly) 0 in size, so it would not push anything, as if I have paused the sound. The solution I had was to just have a buffer regardless of the existence of an audio device. It&rsquo;s not the best fix, but it works for most cases.</p><p>Thinking about it now, I should really look even closer into audio systems in the future for a better solution. There HAS to be a way to do time-based audio. Maybe I do not fully understand how an audio renderer work yet. It really is one of my weak points when it comes to developing games. That&rsquo;s what happens when you use too much of OpenAL and FMOD.</p><p>I learnt a lot from writing one myself though!</p><p>We&rsquo;ll definitely do better next time.</p><h2 id=conclusion>Conclusion</h2><p>The game took two years to complete. It sounds like a long time, but considering everything I learnt, I felt that it was definitely worth every minute.</p><p>A lot of code were written. A lot of code were deleted. A lot of code was refactored, un-refactored and refactored again. Each time I refactor though, I learn enough to refine an opinion on whatever I was refactoring. This should (hopefully) make it such that that I would not refactor as much in the future. For example, I would mostly likely never refactor my vector math library again, and I would most likely never change my naming conventions again.</p><p>And I completed a game!!! Yay!</p><p>Completing the game was the most important part of this project because it made me realize which decisions I made ultimately mattered and which doesn&rsquo;t. Decisions, of course, not just in the final product, but also in the development process. Hopefully, this improves my decision making for the next project, as I tackle something more ambitious.</p><p>Also now I have <em>working code</em> that I can reference! :)</p><p>Stay tuned!</p></div></div></body></html>